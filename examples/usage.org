#+TITLE: org-test Usage Examples

This document demonstrates various match types and usage patterns of org-test.

* Getting Started

org-test uses a simple naming convention:

1. *Test blocks* are named with =test-= prefix: =test-<name>=
2. *Expectation blocks* are named with =expect-= prefix: =expect-<name>-<type>=

Where =<type>= is one of: =exact=, =including=, =excluding=, =not-including=, =contains-all=, =matches=, or =matching=.

** Basic Example

#+begin_src org
,#+NAME: test-hello
,#+begin_src emacs-lisp
,"Hello, World!"
,#+end_src

,#+NAME: expect-hello-exact
,#+begin_example
,Hello, World!
,#+end_example
#+end_src

When you run the test, org-test will:
1. Execute the =test-hello= block
2. Compare its output with =expect-hello-exact= using exact match
3. Report the result

* Test Blocks

You can test any org-babel supported language by naming blocks with =test-= prefix.

** Without Execution

If you don't need to execute the code (e.g., for static content or pre-computed results), use =:eval no= and provide the result in a =#+RESULTS:= block:

#+NAME: test-static-result
#+begin_src emacs-lisp :eval no
"This won't be executed"
#+end_src

#+RESULTS: test-static-result
: "Hello, World!"

#+NAME: expect-static-result-exact
: "Hello, World!"

This uses org-mode's standard =:eval no= header argument. The test will use the cached result from the =#+RESULTS:= block instead of executing the code.

* Match Types

org-test supports various match types for test expectations. Each test can have multiple expectations with different match types.

** Exact Match

The ~exact~ match type requires the output to match exactly (after trimming whitespace).

#+NAME: test-exact-match
#+begin_src emacs-lisp
"Hello, World!"
#+end_src

#+NAME: expect-exact-match-exact
#+begin_example
Hello, World!
#+end_example

** Language Aliases

org-test supports standard org-babel language aliases like ~elisp~ for ~emacs-lisp~.

#+NAME: test-elisp-alias
#+begin_src elisp
(+ 1 2 3)
#+end_src

#+NAME: expect-elisp-alias-exact
: 6

And ~cpp~ for C++:

#+NAME: test-cpp-alias
#+begin_src cpp :results output
#include <iostream>
int main() {
    std::cout << "Hello from C++!" << std::endl;
    return 0;
}
#+end_src

#+NAME: expect-cpp-alias-including
: Hello from C++!

** Including (Substring Match)

The ~including~ match type checks if the expected text appears anywhere in the output.

#+NAME: test-substring
#+begin_src emacs-lisp
"The quick brown fox jumps over the lazy dog"
#+end_src

#+NAME: expect-substring-including
#+begin_example
quick brown fox
#+end_example

** Excluding / Not-Including

These match types verify that the output does NOT contain certain text.

#+NAME: test-excluding
#+begin_src emacs-lisp
"Hello World"
#+end_src

#+NAME: expect-excluding-excluding
#+begin_example
Goodbye
#+end_example

#+NAME: expect-excluding-not-including
#+begin_example
Farewell
#+end_example

** Contains-All (Order-Independent Lines)

The ~contains-all~ match type checks that all expected lines appear in the output, regardless of order.

#+NAME: test-contains-all
#+begin_src emacs-lisp
"Line 1
Line 3
Line 2"
#+end_src

#+NAME: expect-contains-all-contains-all
#+begin_example
Line 1
Line 2
Line 3
#+end_example

** Regex Matching

The ~matches~ or ~matching~ match types support regular expression patterns.

#+NAME: test-regex
#+begin_src emacs-lisp
"The answer is 42"
#+end_src

#+NAME: expect-regex-matches
#+begin_example
answer is [0-9]+
#+end_example

#+NAME: expect-regex-matching
#+begin_example
^The.*42$
#+end_example

* Multiple Expectations

A single test can have multiple expectations with different match types.

#+NAME: test-multi-expect
#+begin_src emacs-lisp
"Hello, World! The year is 2024."
#+end_src

#+NAME: expect-multi-expect-including
#+begin_example
Hello
#+end_example

#+NAME: expect-multi-expect-matching
#+begin_example
[0-9]\{4\}
#+end_example

#+NAME: expect-multi-expect-not-including
#+begin_example
Goodbye
#+end_example

* Running Tests

There are several ways to run tests:

** Interactive Mode

From within Emacs:

#+begin_src emacs-lisp :eval no
;; Test current buffer
M-x org-test-run-current-buffer

;; Test specific file
(org-test-run "examples/usage.org")

;; Test all .org files in directory
(org-test-run "examples/")

;; Test multiple targets
(org-test-run "api.org" "ui.org" "integration.org")
#+end_src

Results are displayed in an =*Org Test*= buffer in org-mode format with clickable links to test locations.

** Batch Mode

From command line:

#+begin_src shell :eval no
# Using nix (if using flake.nix)
nix develop -c check

# Direct emacs invocation
emacs --batch -l org-test.el --eval '(org-test-run "examples/")'
#+end_src

Results are printed to stdout in a compact format.

* Configuration

** Timeout

Set a global timeout for test execution (default: 30 seconds):

#+begin_src emacs-lisp :eval no
;; Set timeout to 60 seconds
(setq org-test-default-timeout 60)

;; Disable timeout
(setq org-test-default-timeout nil)
#+end_src

Tests that exceed the timeout will fail with a timeout error.

** Pre-commit Hooks

You can integrate org-test with git pre-commit hooks:

#+begin_src yaml :eval no
# .pre-commit-config.yaml (using pre-commit-hooks.nix)
repos:
  - repo: local
    hooks:
      - id: org-test
        name: Run org-test
        entry: emacs --batch -l org-test.el --eval '(org-test-run "examples/")'
        language: system
        pass_filenames: false
#+end_src

